\vsection
[Когда не существует алгоритмов данной глубины]
{Тип noexist и отсутствие алгоритмов}

\parhref{https://github.com/boris-a-zolotov \\
	/Computational-complexity-of-quickest-sort \\
	/blob/master/noexist.agda}

\abz Пусть дан список $l$, состоящий из каких-то перестановок $n$ элементов. Пусть также имеется доказательство того, что его элементы — именно перестановки, то есть составлены из неповторяющихся чисел $0 \ldots n-1$: {\tt Unica- \linebreak lized} $l$. Пусть также дано число $d$.

\abz Если мы хотим доказать, что не существует алгоритмов глубины не более чем $d$, распознающих все перестановки в списке $l$, то для этого мы должны построить функцию, которая по каждому алгоритму глубины $d$ строит противоречие. Для этого мы воспользуемся значением типа {\tt noexist}, которое будет содержать результаты перебора и рассмотрения всех возможных алгоритмов.

\abz Значение типа {\tt noexist} может быть одного из двух видов. С одной стороны, алгоритма может не существовать попросту из-за принципа Дирихле (не выполнено условие теоремы~\ref{len2depth}): этой ситуации будет соответствовать значение {\tt basa}, несущее с собой рассматриваемый список, глубину и доказательство того, что $2^\mathrm{depth} < \mathrm{length}\,l$.

\abz С другой стороны, мы можем проверить все возможные сравнения, которые можно только рассмотреть, и для каждого из них получить, что для левого или для правого из двух подсписков нет алгоритма глубины $d-1$. Этой ситуации будет соответствовать значение {\tt pereh}, опять же несущее с собой список, глубину и функцию, возвращающую по каждому из возможных сравнений {\tt noexist} для левого \underline{или} для правого из подсписков-сыновей.

\abz Логической связке «или» соответствует дизъюнктное объединение типов. Если мы хотим доказать утверждение $A \lor B$, мы должны указать, какое конкретно из них доказываем — и построить его доказательство. Дизъюнктному объединению в Agda приписан символ ⊎.

\abz Затем из наличия значения типа {\tt noexist} нам надо будет доказать уже сам факт отсутствия алгоритма. В частности, наличие {\tt noexist}-а для списка из всех $n!$ перестановок длины $n$, должно повлечь то, что произвольный список из $n$ элементов нельзя отсортировать за $d$ шагов.

\abz Таким образом, тип {\tt noexist} может быть определён нами следующим образом:

\begin{verbatim}
data noexist : {n : ℕ} → (l : List (BorderedNlist n)) →
    (depth : ℕ) → Set
where
  basa : {n : ℕ} → (l : List (BorderedNlist n)) → (d : ℕ) →
    (2 ^ d ℕ< length l) → noexist l d
  pereh : {n : ℕ} → (l : List (BorderedNlist n)) → (d : ℕ) →
    ((i j : Fin n) → (i ≢ j) →
      (noexist (cmpFilter i j l) d ⊎ noexist (cmpFilter j i l) d))
    → noexist l (suc d)
\end{verbatim}

Может показаться странным, что при $n=1$ определение {\tt noexist} позволяет построить значение {\tt pereh}, не имея при этом никаких конкретных доказательств. Однако задача сортировки списка из одного элемента не имеет содержательного смысла. Поэтому в дальнейшем мы будем попросту запрещать случай $n=1$.

\abz Оказывается, что при введённом нами определении {\tt noexist} для него можно сразу доказать одно интересное свойство.

\newthm{noexistBigLength}{
{\bf (noexistBigLength)\ \ \ }Если дан список $l$, состоящий из каких-то перестановок длины $n$, при $n \ge 2$, и для какого-то $d$ нашёлся элемент, населяющий тип $\mathtt{noexist}\ l\ d$, то длина $l$ строго больше 1.}

\begin{proof}
Если элемент из типа {\tt noexist} имеет вид $\mathtt{basa}\ l\ d\ p$, тогда $p$ — непременно доказательство того, что $2^d < \lth l$, где $d$ — натуральное число. Тогда $1 \le 2^d < \lth l$ — что и требовалось.

\ms В противном случае, когда элемент из типа {\tt noexist} выглядит как $\mathtt{pereh}\ l\ d\ f$, посмотрим на $f(0,1)$ — она укажет нам на какой-то {\tt noexist} для списка, к которому был применён {\tt filter}. Длина списка, очевидно, не увеличивается после фильтрации.

\ms Так, спускаясь всё глубже в данный нам {\tt noexist}, мы рано или поздно дойдём до {\tt basa} — а в таком случае доказано, что длина много раз отфильтрованного списка всё равно строго больше единицы.

\ms С формальным изложением доказательства читатель может ознакомиться в исходном коде.
\end{proof}

Как мы уже говорили, доказанный факт {\tt noexist} {\tt l} {\tt d} не утверждает напрямую отсутствия алогритма данной глубины для данного списка. Однако несуществование алгоритма может быть выведено из существования {\tt noexist}~{\tt l}~{\tt d}. Справедлива следующая теорема:

\newthm{noexistNoAlg}{
{\bf (noexistNoAlg)\ \ \ }Пусть $n \ge 2$, и дан список $l$, состоящий из перестановок $n$ элементов. Пусть также имеется натуральное число $d$. Тогда, при условии $\mathtt{Unicalized}\ l$, выполнено
$$\mathtt{noexist}\ l\ d\ \ \Longrightarrow\ \ 
	(\exists~a \in \mathtt{Alg}\ l,\ \mathtt{depth}\ a \le d\ \;\Rightarrow\ \bot).$$
\noindent То есть, при условии {\tt noexist}-а из существования нужного алгоритма \linebreak можно вывести ложь — что как раз и означает отсутствие алгоритмов.
}

\begin{proof}
Пусть у нас есть алгоритм $a \in \mathtt{Alg}\ l$ глубины не более $d$ и элемент типа $\mathtt{noexist}\ l\ d$. По определению типа {\tt noexist} последний может принимать один из двух видов:

\begin{enumerate}
\item $\mathtt{basa}\ l\ d\ p$, где $p$ — доказательство того, что $2^d < \lth l$. Вспомним, что у нас, кроме того, есть построенное по теореме \ref{len2depth} доказательство того, что $\lth l \le 2^{\mathtt{depth}\ a}$.

\ms Из неравенства $\mathtt{depth}\ a \le d$, доказательство которого дано нам по условию, можно вывести $2^{\mathtt{depth}\ a} \le 2^d$. Отсюда по теореме \ref{trans_<=} (транзитивность неравенства) получаем $\lth l \le 2^d$.

\ms Из получившихся двух утверждений ($x<y$ и $y \le x$) можно вывести противоречие — $\bot$, как раз то, что нужно.

\ms В исходном коде это выглядит так:

{\footnotesize
\begin{verbatim}
noexistNoAlg : {n : ℕ} → {l : List (BorderedNlist n)} → {dep : ℕ}
  → (2 ℕ≤ n) → Unicalized l
  → noexist l dep → (a : Alg l) → (depth a ℕ≤ dep)
  → ⊥

noexistNoAlg neq u (basa l d p) a q = noComp
  {2 ^ d} {length l}
  p (trans_≤ (len2depth a u) (degs_ineq q))
\end{verbatim}}

\item $\mathtt{pereh}\ l\ d\ f$, где функция $f$ по данным ей позициям для сравнения показывает, для какого из поддеревьев при таком сравнении не найдётся алгоритма сортировки нужной глубины.

\ms Тогда рассмотрим ещё два случая: алгоритм, данный нам по условию, может быть либо листом, либо узлом. Если он лист — то немедленно получаем противоречие с теоремой \ref{noexistBigLength}, ведь длина соответствующего списка — 1. Соответствующий код на Agda:

{\footnotesize
\begin{verbatim}
noexistNoAlg neq u (pereh (.b :: []) d f) (leaf b) q = noteq
  1 (length (b :: []))
  (noexistBigLength neq (pereh (b :: []) d f)) refl
\end{verbatim}}

Если же данный нам алгоритм — узел ($\mathtt{node}\ i\ j\ P\ a_1\ a_2$, где $P$ — доказательство того, что $i \ne j$), то само значение типа {\tt noexist}, которое нам дано, позволяет понять, к какому из поддеревьев этого алгоритма нужно перейти, чтобы получить противоречие.

\ms А именно — $f(i,j)$ указывает нам на {\tt noexist} для одного из поддеревьев. Тогда противоречие получится из применения нашей теоремы к этому {\tt noexist}-у и соответствующему алгоритму ($a_1$ или $a_2$).

\ms Также нам потребуются следующие вспомогательные факты: (1) глубина одновременно {\tt noexist}-а и алгоритма для поддерева стала на единицу меньше\scolon (2) утверждение {\tt Unicalized}, в силу теоремы \ref{filterUnic}, сохранилось для отфильтрованного списка, на котором определён $a_1$ (или $a_2$).

\ms В исходном коде это выглядит так:

{\footnotesize
\begin{verbatim}
noexistNoAlg
  {n} {l} {suc d}
  neq u (pereh .l .d f) (node i j prf a1 a2) q
with (f i j prf)

... | inj₁ NOEX = noexistNoAlg
    neq (filterUnic i j l u) NOEX a1
    (decrease≤ {depth a1} {d}
      (trans_≤ (leftSon {n} {l} {i} {j} {prf} a1 a2) q))

... | inj₂ NOEXREV = noexistNoAlg
    neq
    (filterUnic j i l u) NOEXREV a2
    (decrease≤ {depth a2} {d}
      (trans_≤ (rightSon {n} {l} {i} {j} {prf} a1 a2) q))
\end{verbatim}}
\end{enumerate}
\end{proof}