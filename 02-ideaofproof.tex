\section
[Идея доказательства. Используемые понятия]
{Идея доказательства}

\subsection
[Идея доказательства по Кнуту]
{Идея доказательства}

Описывая перебор, который необходимо произвести, чтобы доказать несуществование алгоритма сортировки 12 элементов за 29 сравнений, доказательство в \cite{Knuth} опирается на следующую идею. Пусть мы хотим доказать, что алгоритмов сортировки сложности $d$ нет — доказательство будем проводить по индукции.

\abz Базой такого доказательства будут списки из перестановок $l$, такие, что $2^d < \mathrm{length}\,l$, доказательство отсутствия алгоритма для которых следует из принципа Дирихле.

\abz Переход же будет строиться на разборе всех возможных сравнений, которые мы можем проверить. Пусть мы хотим показать, что алгоритм сортировки сложности $d$ не может быть построен. Для этого мы рассмотрим все возможные алгоритмы, и для корневого сравнения каждого из них найдём контрпример. Им будет список перестановок, который данным сравнением разбивается на такие подсписки, что хотя бы один из них не может быть отсортирован за $d-1$ шаг. 

\abz Соответственно, при доказательстве перехода для сложности $d$ нам нужно предъявить $n(n-1)\,/\,2$ доказательство невозможности сортировки сложности $d-1$.

\abz Далее мы рассмотрим эту идею в подробностях: нам необходимо определить, как именно мы будем мыслить алгоритмы сортировки и перебирать сравнения.

\subsection
[Определение алгоритма сортировки]
{Алгоритм сортировки}

Пусть дан список $a = [a_0 \ldots a_{n-1}]$ из $n$ элементов, попарно различных и попарно сравнимых. Его в таком случае можно отождествить со списком чисел от $0$ до $n-1$~— то есть, на самом деле, с перестановкой этих чисел.

\abz Наша задача~— отсортировать список $a$, то есть, выяснить, с какой перестановкой его можно отождествить, задавая только вопросы вида «больше ли элемент $a_i$, чем элемент $a_j$?». Если мы поймём это, то будем знать, как переставить элементы списка $a$ так, чтобы получить список $[0\ldots(n-1)]$.

\abz Понятно, что в процессе сравнения элементов списка следующие вопросы зависят от ответов, полученных на предыдущие. Например, если мы выяснили, что $a_0 < a_1$ и $a_1 < a_2$, то вопрос «меньше ли $a_0$, чем $a_2$?» не имеет смысла.

\abz Алгоритмом сортировки будем называть дерево, в узлах которого~— вопросы вида «правда ли, что $a_i < a_j$?»,$\ i,j \in \{0\ldots (n-1)\}$\scolon при этом для каждого узла левое поддерево соответствует ответу «да» на этот вопрос, а правое~— ответу «нет». Вопросы типа «$a_i < a_i$?» мы будем запрещать — они бессмысленны, так как одно из поддеревьев должно получаться пустым.

\abz В листьях же алгоритма находятся перестановки~— причём перестановка помещается в лист, только если вопросы в её предках и выбранные ответы на них однозначно её определяют (она единственная соответствует им всем).

\begin{algom}\label{algm}
Алгоритм сортировки для списка из трёх элементов (или, то же самое, для списка из 0, 1, 2).

\def\td{\text{\rm да}}
\def\tn{\text{\rm нет}}
\def\arws{\ar[ld]_\td \ar[rd]^\tn}

{\footnotesize
$$
\xymatrix{
	& & a_0 < a_1 \arws \\
	& a_1 < a_2 \ar[d]^\tn \ar[ld]_\td & & a_2 < a_0 \ar[d]_\td \ar[rd]^\tn \\
	\excl\!\!\![0,1,2] & a_0 < a_2 \arws & & a_1 < a_2 \arws & \ \ \ [1,0,2] \\
	\ \ \ \ [0,2,1] & & [1,2,0]\ \ \ \ \ [2,0,1] & & \excl\!\!\![2,1,0]
}$$}
\end{algom}

\subsection
[Глубина, количество листьев. Список, на котором задан алгоритм]
{Характеристики алгоритма сортировки}

\abz Заметим, что поддеревья алгоритмов сортировки можно мыслить как частные алгоритмы сортировки, выбирающие ответ не из полного списка перестановок, а из ограниченного: из перестановок, для которых верно соответствующее сравнение.

\abz Например, левое поддерево Алгоритма \ref{algm} сортирует список

$$\bigl[[0,1,2], [0,2,1], [1,2,0]\bigr].$$

\abz Тогда становится понятно, что находится в листьях дерева: алгоритмы сортировки для списка из одной-единственной перестановки.

\abz Если же алгоритм — узел, в котором задан вопрос «$a_i < a_j$?», и он должен выбрать ответ из некоторого списка перестановок (назовём его $l$), то его левый потомок сортирует список $[x \in l \mid x_i < x_j]$, а правый — соответственно, список $[x \in l \mid x_i \not < x_j]$.

\abz В дальнейшем мы также будем говорить, что алгоритм {\it распознаёт} перестановки в том списке, который он сортирует.

\abz Глубиной и количеством листьев алгоритма называются его глубина и количество листьев как дерева. Например, для алгоритма \ref{algm} глубина равна 3, количество листьев — 6.

\abz Несложно видеть, что глубина алгоритма равна наибольшему количеству вопросов, которое он предписывает задать для выяснения перестановки. То есть, в точности его {\bf сложности в наихудшем случае} — таким образом, нам удалось формализовать это понятие.

\abz Количество листьев же примерно соответствует количеству элементов списка, перестановки из которого распознаёт алгоритм. В дальнейшем нами будет доказана теорема о том, что длина этого списка не превосходит количества листьев в алгоритме.

\subsection
[Доказательство оценки сложности алгоритма]
{Оценка сложности алгоритма}

Докажем тривиальную оценку на $S(n)$:

\newthm{optimalsort}{$S(n) \ge \log_2 (n!)$}

\begin{proof}
Посмотрим на оптимальный алгоритм сортировки — он представляет из себя дерево, в листьях которого находятся перестановки. Глубина этого дерева — $S(n)$. Значит, в нём не более $2^{S(n)}$ листьев. Перестановок же в точности $n!$. Отсюда
$$2^{S(n)} \ge n!$$
\vspace{-0.4cm}
$$S(n) \ge \log_2 (n!).$$
\end{proof}

В дальнейшем аналогичный факт будет доказан нами для вновь введённой формализации понятий алгоритма и его сложности. Кроме того, для всех последующих теорем в скобках рядом с их номерами мы будем писать их имена в соответствующих файлах Agda.

\subsection
[Принципы доказательства несуществования алгоритмов]
{О несуществовании алгоритмов}

Теперь мы пытаемся понять, существуют ли алгоритмы заданной глубины, распознающие все перестановки данного списка. По \cite{Knuth}, когда их может не быть?

\begin{enumerate}
\item Если заданная глубина равна $d$, а длина списка перестановок строго больше, чем $2^d$ — тогда существование алгоритма противоречило бы теореме \ref{optimalsort}.

\item Если при проверке всех возможных вопросов, которые могут быть заданы на данном шаге, выясняется, что хотя бы в одном поддереве для каждого из них мы рано или поздно придём к противоречию с теоремой \ref{optimalsort}. Тогда также можно заключить, что нужного алгоритма сортировки не найдётся.
\end{enumerate}

\abz В этом и будет заключаться наша техника доказательства несуществования алгоритмов.

\vfill\eject
\subsection
[Пример «аномального» списка]
{Аномальный список}

\parhref{https://github.com/boris-a-zolotov \\
	/Computational-complexity-of-quickest-sort \\
	/blob/master/anomal\_jumbo\_list.agda}

\abz Нам будет интересно немного обобщить исходную задачу и рассмотреть алгоритмы сортировки произвольных списков перестановок — не только списков всех перестановок n элементов.

\abz В частности, такое обобщение интересно тем, что для демонстрации принципов доказательств, которые мы строим, нам необходимы нетривиальные примеры сортируемых списков, на которых не работает принцип Дирихле и при этом верны строгие неравенства — например, $S(12) > \lceil \log_2 (12!) \rceil$.

\abz Тем не менее, из-за огромной алгоритмической сложности задачи, со списками длины 12! очень сложно работать. Аномальные списки дадут нам такие необходимые примеры меньшей длины.

\ms {\bf Определение.} {\it Список из перестановок $l$ будем называть аномальным, если существует такое натуральное $n$, что длина $l$ меньше $2^n$, но тем не менее все перестановки из $l$ нельзя распознать никаким алгоритмом сортировки, имеющим глубину не более $n$.}

\abz Основную задачу можно переформулировать во введённых терминах так: проверить, является ли список всех перестановок $n$ элементов аномальным.

\begin{exmpl}
Список длины 30, который тем не менее невозможно распознать целиком за 5 сравнений (пусть даже $30 < 2^5$). Это его свойство снабжено формальным доказательством, с которым можно ознакомиться по ссылке.

\parhref{\footnotesize \ \\
	(0,1,2,3,4,5);(0,1,2,3,5,4); \medskip \\
	(1,0,2,3,4,5);(1,0,3,2,4,5);(1,2,0,3,4,5); \\
		(1,2,3,0,4,5);(1,3,0,2,4,5); \medskip \\
	(1,0,2,3,5,4);(1,0,3,2,5,4);(1,2,0,3,5,4); \\
		(1,2,3,0,5,4);(1,3,0,2,5,4); \medskip \\
	(2,0,1,3,4,5);(2,0,3,1,4,5);(2,3,0,1,4,5); \medskip \\
	(2,0,1,3,5,4);(2,0,3,1,5,4);(2,3,0,1,5,4); \medskip \\
	(3,0,1,2,4,5);(3,0,2,1,4,5);(3,1,0,2,4,5); \\
		(3,1,2,0,4,5);(3,2,0,1,4,5);(3,2,1,0,4,5); \medskip \\
	(3,0,1,2,5,4);(3,0,2,1,5,4);(3,1,0,2,5,4); \\
		(3,1,2,0,5,4);(3,2,0,1,5,4);(3,2,1,0,5,4). \\}
\end{exmpl}

\abz Теперь наша задача — зафиксировать и формализовать всё то, что мы только что описали.