\section
[Введение. Основные результаты]
{Введение}

\subsection
[Определение $S(n)$. Постановка задачи]
{Постановка задачи}

Пусть дано натуральное число $n$. Пусть также задан список из $n$ различных элементов, на которых введено отношение порядка~— и больше нам про них ничего не известно. Задача сортировки данного списка заключается в том, чтобы расположить эти элементы в порядке возрастания.

\abz Через $S(n)$ будем обозначать максимальное количество сравнений, которое выполнит оптимальный алгоритм сортировки списка из $n$ элементов. Это значит, что не существует алгоритмов, которые в худшем случае работают быстрее.

\abz Задача поиска $S(n)$ рассмотрена в деталях в книге Дональда Э. Кнута \cite{Knuth}. В частности, в ней приведены значения $S(n)$ для первых натуральных $n$.

\abz В частности, в книге Кнута показано, что при $n<12$ значение $S(n)$ в точности равно тривиальной нижней оценке, которую можно дать на это значение~— $\lceil \log_2 (n!) \rceil$ (мы докажем её в теореме \ref{optimalsort}). В случае $n=12$ книга приводит идею доказательства того, что не существует алгоритмов сортировки, завершающихся за $\lceil \log_2 (12!) \rceil = 29$ шагов. Эта идея опирается на довольно сложный и нетривиальный перебор.

\abz Цель данной работы~— сделать из доказательств перебором, аналогичных тем, к которым нас отсылает Кнут, формальные доказательства несуществования алгоритмов заданной сложности, и затем верифицировать их с помощью компьютера. В частности, верификация будет означать, что рассмотрены все необходимые случаи и это сделано без ошибок.

\subsection
[Agda и изоморфизм Карри---Ховарда]
{Инструментарий}

\abz Для формализации и верификации доказательств мы будем использовать язык Agda. Если посмотреть с одной стороны~— это немного странный функциональный язык программирования. Но с другой~— его система типов настолько мощна, что её можно использовать для доказательства математических утверждений. Делается это при помощи изоморфизма Карри-Ховарда~— соответствия, связывающего между собой типы в языках программирования и логические формулы. 

\abz Например, рассмотрим функцию $\lambda x.x$, возвращающую свой аргумент неизменным. Её тип~— $\mathtt{\forall\,a\,.\,a \rar a}$. С другой стороны, мы можем трактовать этот тип как формулу исчисления предикатов (а именно~— импликацию $a \Rightarrow a$), и функцию~— как доказательство этой формулы. Подробнее об изоморфизме Карри—Ховарда и о связанных с ним понятиях можно узнать в книге М.\,Соренсена \cite{Sorensen}.

\abz В дальнейшем~— когда доказательства теорем приводятся в виде исходного кода на Agda~— необходимо мыслить практически каждый вводимый нами тип, как некоторое утверждение, которому требуется доказательство.

\abz С элементарными примерами доказательств, верифицируемых посредством Agda, читатель может ознакомиться в руководстве \cite{ELTE}.

\abz Также примером работы с верификацией в Agda может послужить статья \linebreak на портале Habrahabr \cite{Habrahabr}: в ней описывается алгоритм быстрой сортировки списка и доказывается, что результат его работы представляет из себя переставленный исходный список, в котором элементы упорядочены требуемым образом.

\subsection
[Основные результаты. Решение задачи и поиск аномалий]
{Основные результаты}

\begin{enumerate}
\item На языке Agda было формализовано понятие алгоритма сортировки списка значений, а также был построен инструментарий, позволяющий доказывать или опровергать существование алгоритма, сортирующего данный список\scolon

\item Была написана программа на языке Haskell, позволяющая по данному списку и данному $s$ (наихудшей временной сложности сортировки списка) либо построить  алгоритм сортировки, использующий не более $s$ сравнений, либо привести доказательство, опровергающее существование такого алгоритма.
\end{enumerate}

Однако, сам размер доказательства, получаемого нашим способом, достаточно велик: $\Omega\,((n^2)^s \cdot n!)$. Поэтому, например, уже для $n=6$ верификация на Agda уже не завершается за обозримое время на среднем персональном компьютере.

\abz Также было введено понятие аномального списка: списка, сложность сортировки которого превышает $\log_2 (n!)$. Если рассматривать естественную задачу поиска $S(n)$, наименьший такой список получается при $n=12$, но в силу крайне большой вычислительной сложности перебора всех сортирующих алгоритмов он не может быть разобран нами с помощью подручных средств.

\abz Тем не менее, нам удалось его «сымитировать»: найден список из 30 перестановок такой, что все перестановки в нём нельзя распознать за 5 сравнений (хотя $30 < 2^5$). Доказательство того, что все его элементы действительно нельзя распознать за 5 сравнений, не опирается на принцип Дирихле и другие тривиальные соображения, а в полной мере демонстрирует принципы, заложенные нами в доказательство несуществования сортирующих алгоритмов заданной сложности.

\abz Исходные коды всех программ, написанных в процессе создания данной работы, хранятся в репозитории на GitHub:

\begin{center}
	\url{https://github.com/boris-a-zolotov/Computational-complexity-of-quickest-sort}
\end{center}