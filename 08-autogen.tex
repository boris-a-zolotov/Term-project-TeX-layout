\vsection
[Автоматическое построение доказательства по списку]
{Автоматическое построение доказательства}

\parhref{https://github.com/boris-a-zolotov \\
/Computational-complexity-of-quickest-sort/blob \\
/master/z\_autoproof\_unicalized.hs}

\parhref{https://github.com/boris-a-zolotov \\
/Computational-complexity-of-quickest-sort/blob \\
/master/z\_autoproof\_noexistOrAlg.hs}

\abz Пользователь ввёл список $l$ из перестановок длины $n$ (именно перестановок, то есть списков, элементы которых попарно различны) и глубину $d$. Мы хотим научиться автоматически решать задачу, которая была поставлена ранее: вывести либо алгоритм, распознающий все перестановки в списке за не более чем $d$ сравнений, либо доказательство того, что таких алгоритмов нет.

\abz Язык, с которым мы теперь работаем — Haskell. Мы будем активно пользоваться введёнными нами конструкциями {\tt Unicalized} и {\tt noexist}, которые очень удобно генерировать программно и которые помогают получить нужный результат.

\abz Как вывести доказательство {\tt Unicalized} для данного списка? Для этого нужно вывести доказательство попарной различности элементов каждой из составляющих его перестановок. Оно строится как функция, берущая на вход номера элементов в перестановке. Зафиксировав, что она не определена на равных аргументах и на аргументах не меньше $n$, несложно вывести нужные доказательства в остальных случаях. С конкретной реализацией читатель может ознакомиться в исходном коде.

\abz Для поиска алгоритма введём следующий тип данных:

\begin{verbatim}
data AlgSearch =
        Leaf [Int] |
        Node Int Int AlgSearch AlgSearch |
        Noexist String | Wtf
\end{verbatim}

\abz Он хранит в себе меньше информации, чем конструкции, используемые нами в Agda — но для вывода кода, который потом будет верифицирован при помощи Agda, этой информации вполне хватит.

\abz Алгоритм поиска построим следующим образом: пусть ему даны список $l$ из перестановок и глубина $d$ — тогда

\begin{enumerate}
\item Если $2^d < \lth l$, то алгоритма сортировки существовать не должно~— возвращаем {\tt Noexist} вместе со строкой, содержащей название соответствующего {\tt noexist}-а (он будет построен с помощью конструктора {\tt basa}), список, глубину и доказательство неравенства $2^d < \lth l$.

\item В противном случае, и если длина $l = [x]$ равна одному, алгоритм сортировки, несомненно, есть — возвращаем {\tt Leaf} $x$.

\item Если длина $l$ больше одного, то рассмотрим все возможные сравнения, которые можно произвести. Если хотя бы для одного из них получилось построить алгоритмы глубиной $d-1$, распознающие и перестановки, удовлетворяющие прямому сравнению, и перестановки, удовлетворяющие обратному — то мы делаем из этих двух алгоритмов узел и возвращаем его «наверх».

\smallskip\noindent Если же для каждого сравнения хотя бы для одного из фильтрованных списков и глубины $d-1$ алгоритм возвращает {\tt Noexist}, то с использованием строк, которые вернулись вместе с ними, можно построить {\tt noexist} для исходного списка и глубины $d$. Наверх вернётся {\tt Noexist} вместе со строчкой–описанием {\tt noexist}-а.

\item Заметим, что длина $l$ вообще не может в интересующих нас случаях обратиться в ноль: если алгоритм поиска встречает список длины 1, он тут же возвращает {\tt Leaf}. Если же пустой список получился в качестве одного из побочных при фильтре по сравнению, то другой побочный список имеет ту же длину, что и исходный, но глубину на единицу меньше — для него наверняка докажется {\tt noexist}, если для исходного списка не нашлось алгоритма сортировки.
\end{enumerate}

После завершения работы алгоритма поиска мы получим либо описание алгоритма, распознающего все перестановки — и его можно просто записать в файл для Agda, либо описание {\tt noexist}-а — и чтобы из него получить доказательство отсутствия алгоритмов, нужно приписать в конец применение теоремы \ref{noexistNoAlg} к этому {\tt noexist}-у.

\abz Более подробно изучить реализацию можно, ознакомившись с исходным кодом.