\vsection
[Полученные результаты. Открытые вопросы]
{Результаты}

В результате была решена поставленная задача: по списку из перестановок и глубине мы получаем либо алгоритм глубины не больше заданной, распознающий все перестановки из списка, либо доказательство отсутствия таковых.

\abz Например, возможности среднего персонального компьютера позволили нам с использованием нашего алгоритма в реальном времени (не более чем за 5–10 минут) доказать, что $S(5) = 7$.

\abz Отсутствие алгоритмов глубины строго меньше, чем 7, было получено из неравенства $2^6 < 120$. Алгоритм глубины 7 был построен с помощью нашего алгоритма перебора, с ним можно ознакомиться по ссылке:

\parhref{https://github.com/boris-a-zolotov \\
	/Computational-complexity-of-quickest-sort \\
	/blob/master/allperms\_sorted.agda}

\abz Было успешно верифицировано с помощью Agda, что этот алгоритм распознаёт все перестановки списка $[0,1,2,3,4]$.

\abz Поиск следующих значений $S(n)$ требует значительно б\'oльших затрат времени и оперативной памяти. Проблема заключается в том, что построенный нами алгоритм перечисляет все перестановки длины $n$, что порождает большой объём данных, которые необходимо хранить в памяти.

\abz Если оценить, сколько раз при построении получаемого перебором значения типа {\tt noexist} выписываются все перестановки из исходного списка, несложно получить нижнюю оценку на асимптотику размера доказательства, конструируемого для списка $l$ и глубины $d$:

$$\Omega\,((n^2)^s \cdot n!).$$

\abz Возможно, помог бы другой способ хранения перестановок, который требует меньше памяти, но для которого по-прежнему несложно доказывать нужные факты про фильтры и сортировки. Например, способ хранения, связанный с числами в факториальной системе счисления, очень ёмкий — но для него сложно доказать то, за что в нашем случае отвечал просто определяемый тип Unicalized.

\abz Также оптимизации нашего алгоритма могло бы помочь использование техники, введённой Д.\,Э.\,Кнутом в \cite{Knuth}, связанной с понятием {\it эффективности} алгоритма и пересчётом матриц для её вычисления.

\abz Составление доказательств для этой работы включало в себя и неудачный опыт: например, попытки хранить перестановки в виде чисел в факториальной системе счисления. Также потерпело неудачу определение алгоритма сортировки «снизу», а не «сверху» — когда в узле хранится конкатенация списков потомков, а не списки для потомков определяются как применения функции {\tt filter} к родительскому.

\abz Таким образом, итогом данной работы явились построенная техника проверки существования алгоритмов сортировки заданной сложности (и эти результаты могут быть формально проверены) и примеры списков, для которых не существует алгоритмов сортировки конкретной глубины — из соображений менее тривиальных, чем принцип Дирихле.